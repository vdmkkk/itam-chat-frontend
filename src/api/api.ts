/* tslint:disable */
/* eslint-disable */
/**
 * ITAM Chat Backend
 * Backend for a messenger app. Provides JWT auth, user search, chats with previews, chat contents with pagination, and real-time messaging via WebSockets.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ChatCreate {
    'user_ids': Array<string>;
    'name'?: string | null;
    'avatar'?: string | null;
}
export interface ChatDetail {
    'id': string;
    'is_group': boolean;
    'name'?: string | null;
    'avatar'?: string | null;
    'users': Array<UserPublic>;
}
export interface ChatPreview {
    'id': string;
    'name': string;
    'avatar'?: string | null;
    'is_group': boolean;
    'last_message'?: LastMessagePreview | null;
}
export interface ChatWithMessagesPage {
    'chat': ChatDetail;
    'messages': Array<MessageOut>;
    'total': number;
    'limit': number;
    'offset': number;
}
export interface HTTPValidationError {
    'detail'?: Array<ValidationError>;
}
export interface LastMessagePreview {
    'id': string;
    'from_user_id': string;
    'text_content'?: string | null;
    'image_content'?: string | null;
    'created_at': string;
}
export interface LocationInner {
}
export interface LoginRequest {
    'username_or_email': string;
    'password': string;
}
export interface MessageCreate {
    'text_content'?: string | null;
    'image_content'?: string | null;
}
export interface MessageOut {
    'id': string;
    'chat_id': string;
    'from_user_id': string;
    'text_content'?: string | null;
    'image_content'?: string | null;
    'created_at': string;
    'seen_by'?: Array<MessageSeenOut>;
}
export interface MessageSeenOut {
    /**
     * User who has seen the message
     */
    'user_id': string;
    'seen_at': string;
}
export interface PageChatPreview {
    'items': Array<ChatPreview>;
    'total': number;
    'limit': number;
    'offset': number;
}
export interface PageUserSearchPublic {
    'items': Array<UserSearchPublic>;
    'total': number;
    'limit': number;
    'offset': number;
}
export interface Token {
    'access_token': string;
    'token_type'?: string;
}
export interface UserCreate {
    'email': string;
    'username': string;
    'password': string;
    'first_name'?: string | null;
    'last_name'?: string | null;
    'avatar'?: string | null;
}
export interface UserPublic {
    'id': string;
    'email': string;
    'username': string;
    'first_name'?: string | null;
    'last_name'?: string | null;
    'avatar'?: string | null;
    'last_seen'?: string | null;
}
export interface UserSearchPublic {
    'id': string;
    'username': string;
    'first_name'?: string | null;
    'last_name'?: string | null;
    'avatar'?: string | null;
}
export interface ValidationError {
    'loc': Array<LocationInner>;
    'msg': string;
    'type': string;
}

/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate with username or email and password. Returns a Bearer JWT. In DEV mode tokens have no expiration; in production they expire after the configured TTL.
         * @summary Login and receive a JWT
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('loginLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint for Swagger\'s Authorize flow. Provide username (or email) and password. Returns a Bearer JWT.
         * @summary OAuth2 Password Grant (Swagger Authorize)
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginTokenTokenPost: async (username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginTokenTokenPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginTokenTokenPost', 'password', password)
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user account with unique email and username.
         * @summary Register a new user
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRegisterPost: async (userCreate: UserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('registerRegisterPost', 'userCreate', userCreate)
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate with username or email and password. Returns a Bearer JWT. In DEV mode tokens have no expiration; in production they expire after the configured TTL.
         * @summary Login and receive a JWT
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginLoginPost(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint for Swagger\'s Authorize flow. Provide username (or email) and password. Returns a Bearer JWT.
         * @summary OAuth2 Password Grant (Swagger Authorize)
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginTokenTokenPost(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginTokenTokenPost(username, password, grantType, scope, clientId, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginTokenTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user account with unique email and username.
         * @summary Register a new user
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerRegisterPost(userCreate: UserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerRegisterPost(userCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.registerRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authenticate with username or email and password. Returns a Bearer JWT. In DEV mode tokens have no expiration; in production they expire after the configured TTL.
         * @summary Login and receive a JWT
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.loginLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint for Swagger\'s Authorize flow. Provide username (or email) and password. Returns a Bearer JWT.
         * @summary OAuth2 Password Grant (Swagger Authorize)
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginTokenTokenPost(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.loginTokenTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user account with unique email and username.
         * @summary Register a new user
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRegisterPost(userCreate: UserCreate, options?: RawAxiosRequestConfig): AxiosPromise<UserPublic> {
            return localVarFp.registerRegisterPost(userCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticate with username or email and password. Returns a Bearer JWT. In DEV mode tokens have no expiration; in production they expire after the configured TTL.
     * @summary Login and receive a JWT
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint for Swagger\'s Authorize flow. Provide username (or email) and password. Returns a Bearer JWT.
     * @summary OAuth2 Password Grant (Swagger Authorize)
     * @param {string} username 
     * @param {string} password 
     * @param {string | null} [grantType] 
     * @param {string} [scope] 
     * @param {string | null} [clientId] 
     * @param {string | null} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginTokenTokenPost(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginTokenTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user account with unique email and username.
     * @summary Register a new user
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registerRegisterPost(userCreate: UserCreate, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).registerRegisterPost(userCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatsApi - axios parameter creator
 */
export const ChatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a direct chat with another user or a group chat when providing 2+ other users or a name.
         * @summary Create a chat (direct or group)
         * @param {ChatCreate} chatCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatChatsPost: async (chatCreate: ChatCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatCreate' is not null or undefined
            assertParamExists('createChatChatsPost', 'chatCreate', chatCreate)
            const localVarPath = `/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns chat details and paginated messages (newest first).
         * @summary Get chat details and messages
         * @param {string} chatId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatChatsChatIdGet: async (chatId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('getChatChatsChatIdGet', 'chatId', chatId)
            const localVarPath = `/chats/{chat_id}`
                .replace(`{${"chat_id"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns chat previews with last message. Supports pagination.
         * @summary List chats for current user
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChatsChatsGet: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a text or image message to a chat; primarily for fallback to WS.
         * @summary Send a message (REST)
         * @param {string} chatId 
         * @param {MessageCreate} messageCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessageRestChatsChatIdMessagesPost: async (chatId: string, messageCreate: MessageCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('sendMessageRestChatsChatIdMessagesPost', 'chatId', chatId)
            // verify required parameter 'messageCreate' is not null or undefined
            assertParamExists('sendMessageRestChatsChatIdMessagesPost', 'messageCreate', messageCreate)
            const localVarPath = `/chats/{chat_id}/messages`
                .replace(`{${"chat_id"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatsApi - functional programming interface
 */
export const ChatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a direct chat with another user or a group chat when providing 2+ other users or a name.
         * @summary Create a chat (direct or group)
         * @param {ChatCreate} chatCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChatChatsPost(chatCreate: ChatCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChatChatsPost(chatCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.createChatChatsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns chat details and paginated messages (newest first).
         * @summary Get chat details and messages
         * @param {string} chatId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatChatsChatIdGet(chatId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatWithMessagesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatChatsChatIdGet(chatId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.getChatChatsChatIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns chat previews with last message. Supports pagination.
         * @summary List chats for current user
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChatsChatsGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageChatPreview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChatsChatsGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.listChatsChatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a text or image message to a chat; primarily for fallback to WS.
         * @summary Send a message (REST)
         * @param {string} chatId 
         * @param {MessageCreate} messageCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessageRestChatsChatIdMessagesPost(chatId: string, messageCreate: MessageCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessageRestChatsChatIdMessagesPost(chatId, messageCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.sendMessageRestChatsChatIdMessagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatsApi - factory interface
 */
export const ChatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatsApiFp(configuration)
    return {
        /**
         * Create a direct chat with another user or a group chat when providing 2+ other users or a name.
         * @summary Create a chat (direct or group)
         * @param {ChatCreate} chatCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatChatsPost(chatCreate: ChatCreate, options?: RawAxiosRequestConfig): AxiosPromise<ChatDetail> {
            return localVarFp.createChatChatsPost(chatCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns chat details and paginated messages (newest first).
         * @summary Get chat details and messages
         * @param {string} chatId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatChatsChatIdGet(chatId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ChatWithMessagesPage> {
            return localVarFp.getChatChatsChatIdGet(chatId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns chat previews with last message. Supports pagination.
         * @summary List chats for current user
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChatsChatsGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageChatPreview> {
            return localVarFp.listChatsChatsGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a text or image message to a chat; primarily for fallback to WS.
         * @summary Send a message (REST)
         * @param {string} chatId 
         * @param {MessageCreate} messageCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessageRestChatsChatIdMessagesPost(chatId: string, messageCreate: MessageCreate, options?: RawAxiosRequestConfig): AxiosPromise<MessageOut> {
            return localVarFp.sendMessageRestChatsChatIdMessagesPost(chatId, messageCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatsApi - object-oriented interface
 */
export class ChatsApi extends BaseAPI {
    /**
     * Create a direct chat with another user or a group chat when providing 2+ other users or a name.
     * @summary Create a chat (direct or group)
     * @param {ChatCreate} chatCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createChatChatsPost(chatCreate: ChatCreate, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).createChatChatsPost(chatCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns chat details and paginated messages (newest first).
     * @summary Get chat details and messages
     * @param {string} chatId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChatChatsChatIdGet(chatId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).getChatChatsChatIdGet(chatId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns chat previews with last message. Supports pagination.
     * @summary List chats for current user
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listChatsChatsGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).listChatsChatsGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a text or image message to a chat; primarily for fallback to WS.
     * @summary Send a message (REST)
     * @param {string} chatId 
     * @param {MessageCreate} messageCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendMessageRestChatsChatIdMessagesPost(chatId: string, messageCreate: MessageCreate, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).sendMessageRestChatsChatIdMessagesPost(chatId, messageCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.healthHealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthHealthGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthHealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fast user search across username, first_name, and last_name. Matches are case-insensitive and prioritize exact/prefix username matches.
         * @summary Search users
         * @param {string} q Query string
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersSearchGet: async (q: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchUsersSearchGet', 'q', q)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Fast user search across username, first_name, and last_name. Matches are case-insensitive and prioritize exact/prefix username matches.
         * @summary Search users
         * @param {string} q Query string
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsersSearchGet(q: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageUserSearchPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsersSearchGet(q, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchUsersSearchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Fast user search across username, first_name, and last_name. Matches are case-insensitive and prioritize exact/prefix username matches.
         * @summary Search users
         * @param {string} q Query string
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersSearchGet(q: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageUserSearchPublic> {
            return localVarFp.searchUsersSearchGet(q, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 */
export class SearchApi extends BaseAPI {
    /**
     * Fast user search across username, first_name, and last_name. Matches are case-insensitive and prioritize exact/prefix username matches.
     * @summary Search users
     * @param {string} q Query string
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchUsersSearchGet(q: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUsersSearchGet(q, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



